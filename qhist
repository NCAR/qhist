#!/usr/bin/env python2

import sys, argparse, subprocess
from datetime import datetime, timedelta
from itertools import izip
from signal import signal, SIGPIPE, SIG_DFL

# Use default signal behavior on system rather than throwing IOError
signal(SIGPIPE, SIG_DFL)

# System constants
pbslog_path = "/gpfs/pbs/server_priv/accounting/"
log_start	= datetime(2016, 12, 10)
cur_date	= datetime.today()
pbsdate_fmt	= "%Y%m%d"
wide_fmt	= "%b-%dT%H:%M"
slim_fmt 	= "%d-%H%M"
list_fmt	= "%Y-%m-%dT%H:%M:%S"
out_fmt		= "{:7.7}  {:7.7}  {:7.7}  {:>5.5}  {:7.7}  {:7.7}  {:7.7}  {:>7.7}  {:>7.7}  {:>7.7}"

# Operational constants
time_vars	= ["ctime","qtime","etime","start","end"]
one_day		= timedelta(days = 1)

# Job parameters and argument dictionary storage
param_list	= [ "user","queue","Resource_List.nodect","ctime","start","end",
				"resources_used.mem","resources_used.cpupercent",
				"resources_used.walltime","jobname","Resource_List.select",
				"exec_vnode" ]
labels		= [ "Job ID","User","Queue","Nodes","Submit Time",
				"Start Time","Finish Time","Mem/Node(GB)","CPU/Node (%)",
				"Walltime (s)","Job Name","Resources","Node List" ]
sort_index	= { "id"		: 0,
				"user"		: 1,
				"queue"		: 2,
				"nodes"		: 3,
				"submit"	: 4,
				"start"		: 5,
				"finish"	: 6,
				"memory"	: 7,
				"cpu"		: 8,
				"walltime"	: 9,
				"name"		: 10 }
item_fmt	= { 3	: "{:d}",
				7	: "{:0.1f}",
				8	: "{:0.1f}",
				9	: "{:d}" }


num_params	= len(param_list)

arg_help	= { "brief"		: "only output the PBS job IDs",
				"days"		: "number of days prior to search (default = 0)",
				"list"		: "display untruncated output in list format",
				"nodes"		: "show list of nodes for each job",
				"period"	: "search over specific date range (YYYYMMDD-YYYYMMDD)",
				"sort"		: "sort by id, user, queue, nodes, submit, start, finish, memory, cpu, walltime, or name",
				"user"		: "filter jobs by a specific user",
				"wide"		: "use wide table columns and show job names" }

#
## FUNCTION DEFINITIONS
#

def run_grep(log):
	proc 		= subprocess.Popen(["grep", "-a", ";E;", log],
					stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
	out_data 	= proc.communicate()[0]

	return proc.returncode, out_data

def get_time_bounds(args):
	if args.period and '-' in args.period:
		try:
			bounds = [datetime.strptime(d, pbsdate_fmt) for
						d in args.period.split('-')]
		except ValueError:
			print "Date range not in a valid format..."
			print "    showing today's jobs instead\n"
			bounds = [cur_date - one_day, cur_date]
	else:
		bounds = [cur_date - one_day * int(args.days), cur_date]
		
	# Check to make sure bounds fit into range
	if bounds[0] < log_start:
		print "Starting date preceeds beginning of logs..."
		print "    using {} instead\n".format(log_start.strftime(pbsdate_fmt))
		bounds[0] = log_start
	
	if bounds[1] > cur_date:
		print "Ending date is in the future..."
		print "    using today instead\n"
		bounds[1] = cur_date
	
	return bounds

def filter_log(log_data, terms):
	post_data = []

	for entry in log_data:
		if all(item in entry for item in terms):
			post_data.append(entry)
	
	return post_data

def param_conversion(param, content, nodes):
	if param in time_vars:
		content	= datetime.fromtimestamp(float(content))
	elif "nodect" in param:
		content = int(content)
	elif "walltime" in param:
		tvals	= [int(val) for val in content.split(":")]
		content	= tvals[0] * 3600 + tvals[1] * 60 + tvals[2]
	elif "used.mem" in param:
		content	= (float(content[:-2]) / 1048576) / nodes
	elif "cpupercent" in param:
		content	= float(content) / nodes
	elif "vnode" in param:
		content = '+'.join([n[1:].split(':')[0] for n in content.split('+')])
	
	return content

def format_log(jobs, time_fmt):
	for record in jobs:
		for n in range(3, 10):
			if n in item_fmt:
				record[n] = item_fmt[n].format(record[n])
			elif n > 3 and n < 7:
				record[n] = datetime.strftime(record[n], time_fmt)
	
	return jobs

def sort_log(jobs, method):
	# Get sort index based on method
	if method in sort_index:
		si = sort_index[method]
		jobs.sort(key = lambda r: r[si], reverse = True)
	else:
		print "Sorting method {} not recognized...".format(method)
		print "    using finish time instead\n"

def process_log(log_data):
	jobs	= []
	records = [None] * (num_params + 1)

	for entry in log_data:
		records[0], job_data = entry.split(';')[2:4]

		for item in job_data.split():
			param, content = item.split('=', 1)

			if param in param_list:
				content = param_conversion(param, content, records[3])
				records[param_list.index(param) + 1] = content

		jobs.append(records[:])
	
	return jobs

def print_list(jobs):
	for records in jobs:
		len_max = max(len(item) for item in labels)
		fmt_str = "{:" + str(len_max) + "} {} {}"
		
		for l, r in izip(labels, records):
			print fmt_str.format(l, '=', r)
		
		print

def print_table(jobs, args, out_fmt):
	for records in jobs:
		if args.wide:
			print out_fmt.format(*records[:-2])
		else:
			print out_fmt.format(*records[:-3])

		if args.nodes:
			print "    {}".format(records[-1])

#
## MAIN PROGRAM EXECUTION
#

if __name__ == "__main__":
	# Define command line arguments
	parser = argparse.ArgumentParser(prog = "qhist",					
				description = "Search PBS logs for finished jobs.")

	# Optional arguments
	parser.add_argument("-b", "--brief", help = arg_help["brief"],
			action = "store_true")
	parser.add_argument("-d", "--days", help = arg_help["days"],
			default = 0)
	parser.add_argument("-l", "--list", help = arg_help["list"],
			action = "store_true")
	parser.add_argument("-n", "--nodes", help = arg_help["nodes"],
			action = "store_true")
	parser.add_argument("-p", "--period", help = arg_help["period"])
	parser.add_argument("-s", "--sort", help = arg_help["sort"],
			default = "finish")
	parser.add_argument("-u", "--user", help = arg_help["user"])
	parser.add_argument("-w", "--wide", help = arg_help["wide"],
			action = "store_true")

	# Handle job ID and log path arguments
	args = parser.parse_args()

	# Collect search terms
	terms = []
	
	if args.user:
		terms += ["user={}".format(args.user)]

	# Set time format based on output choice
	if args.list:
		time_fmt 	= list_fmt
	elif args.wide:
		out_fmt		= "{:7.7}  {:15.15}  {:10.10}  {:>5.5}  {:12.12}  {:12.12}  {:12.12}  {:>12.12}  {:>12.12}  {:>12.12}  {}"
		time_fmt 	= wide_fmt
	else:
		labels		= ["Job ID","User","Queue","Nodes","Submit",
						"Start","Finish","Mem(GB)","CPU(%)","Wall(s)","Node List"]
		time_fmt 	= slim_fmt

	# Get start and end files
	bounds 		= get_time_bounds(args)
	loop_date	= bounds[0]
	log_data	= []

	while loop_date <= bounds[1]:
		log		 			= pbslog_path + datetime.strftime(loop_date, pbsdate_fmt)
		status, raw_data 	= run_grep(log)

		if status == 0:
			log_data += filter_log(raw_data.splitlines(), terms)

		loop_date += one_day
	
	if len(log_data) > 0:
		jobs = process_log(log_data)

		# Sort and format log 
		sort_log(jobs, args.sort)
		format_log(jobs, time_fmt)
		
		if not (args.list or args.brief):
			print out_fmt.format(*labels[:-1])

		if args.list:
			print_list(jobs)
		elif args.brief:
			for records in jobs:
				print records[0]
		else:
			print_table(jobs, args, out_fmt)
	else:
		print "No jobs found matching search criteria"
